module Core.Iter.Traits.Accum
#set-options "--fuel 0 --ifuel 1 --z3rlimit 15"
open Core

(* item error backend *)

(* item error backend *)

let impl: t_Sum i8 i8 = { sum = fun (iter: i) -> () }

let impl: t_Product i8 i8 = { product = fun (iter: i) -> () }

let impl: t_Sum i8 i8 = { sum = fun (iter: i) -> () }

let impl: t_Product i8 i8 = { product = fun (iter: i) -> () }

let impl: t_Sum i16 i16 = { sum = fun (iter: i) -> () }

let impl: t_Product i16 i16 = { product = fun (iter: i) -> () }

let impl: t_Sum i16 i16 = { sum = fun (iter: i) -> () }

let impl: t_Product i16 i16 = { product = fun (iter: i) -> () }

let impl: t_Sum i32 i32 = { sum = fun (iter: i) -> () }

let impl: t_Product i32 i32 = { product = fun (iter: i) -> () }

let impl: t_Sum i32 i32 = { sum = fun (iter: i) -> () }

let impl: t_Product i32 i32 = { product = fun (iter: i) -> () }

let impl: t_Sum i64 i64 = { sum = fun (iter: i) -> () }

let impl: t_Product i64 i64 = { product = fun (iter: i) -> () }

let impl: t_Sum i64 i64 = { sum = fun (iter: i) -> () }

let impl: t_Product i64 i64 = { product = fun (iter: i) -> () }

let impl: t_Sum i128 i128 = { sum = fun (iter: i) -> () }

let impl: t_Product i128 i128 = { product = fun (iter: i) -> () }

let impl: t_Sum i128 i128 = { sum = fun (iter: i) -> () }

let impl: t_Product i128 i128 = { product = fun (iter: i) -> () }

let impl: t_Sum isize isize = { sum = fun (iter: i) -> () }

let impl: t_Product isize isize = { product = fun (iter: i) -> () }

let impl: t_Sum isize isize = { sum = fun (iter: i) -> () }

let impl: t_Product isize isize = { product = fun (iter: i) -> () }

let impl: t_Sum u8 u8 = { sum = fun (iter: i) -> () }

let impl: t_Product u8 u8 = { product = fun (iter: i) -> () }

let impl: t_Sum u8 u8 = { sum = fun (iter: i) -> () }

let impl: t_Product u8 u8 = { product = fun (iter: i) -> () }

let impl: t_Sum u16 u16 = { sum = fun (iter: i) -> () }

let impl: t_Product u16 u16 = { product = fun (iter: i) -> () }

let impl: t_Sum u16 u16 = { sum = fun (iter: i) -> () }

let impl: t_Product u16 u16 = { product = fun (iter: i) -> () }

let impl: t_Sum u32 u32 = { sum = fun (iter: i) -> () }

let impl: t_Product u32 u32 = { product = fun (iter: i) -> () }

let impl: t_Sum u32 u32 = { sum = fun (iter: i) -> () }

let impl: t_Product u32 u32 = { product = fun (iter: i) -> () }

let impl: t_Sum u64 u64 = { sum = fun (iter: i) -> () }

let impl: t_Product u64 u64 = { product = fun (iter: i) -> () }

let impl: t_Sum u64 u64 = { sum = fun (iter: i) -> () }

let impl: t_Product u64 u64 = { product = fun (iter: i) -> () }

let impl: t_Sum u128 u128 = { sum = fun (iter: i) -> () }

let impl: t_Product u128 u128 = { product = fun (iter: i) -> () }

let impl: t_Sum u128 u128 = { sum = fun (iter: i) -> () }

let impl: t_Product u128 u128 = { product = fun (iter: i) -> () }

let impl: t_Sum usize usize = { sum = fun (iter: i) -> () }

let impl: t_Product usize usize = { product = fun (iter: i) -> () }

let impl: t_Sum usize usize = { sum = fun (iter: i) -> () }

let impl: t_Product usize usize = { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping i8) (Core.Num.Wrapping.t_Wrapping i8) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping i8) (Core.Num.Wrapping.t_Wrapping i8) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping i8) (Core.Num.Wrapping.t_Wrapping i8) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping i8) (Core.Num.Wrapping.t_Wrapping i8) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping i16) (Core.Num.Wrapping.t_Wrapping i16) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping i16) (Core.Num.Wrapping.t_Wrapping i16) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping i16) (Core.Num.Wrapping.t_Wrapping i16) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping i16) (Core.Num.Wrapping.t_Wrapping i16) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping i32) (Core.Num.Wrapping.t_Wrapping i32) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping i32) (Core.Num.Wrapping.t_Wrapping i32) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping i32) (Core.Num.Wrapping.t_Wrapping i32) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping i32) (Core.Num.Wrapping.t_Wrapping i32) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping i64) (Core.Num.Wrapping.t_Wrapping i64) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping i64) (Core.Num.Wrapping.t_Wrapping i64) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping i64) (Core.Num.Wrapping.t_Wrapping i64) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping i64) (Core.Num.Wrapping.t_Wrapping i64) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping i128) (Core.Num.Wrapping.t_Wrapping i128) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping i128) (Core.Num.Wrapping.t_Wrapping i128) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping i128) (Core.Num.Wrapping.t_Wrapping i128) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping i128) (Core.Num.Wrapping.t_Wrapping i128) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping isize) (Core.Num.Wrapping.t_Wrapping isize) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping isize) (Core.Num.Wrapping.t_Wrapping isize) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping isize) (Core.Num.Wrapping.t_Wrapping isize) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping isize) (Core.Num.Wrapping.t_Wrapping isize) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping u8) (Core.Num.Wrapping.t_Wrapping u8) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping u8) (Core.Num.Wrapping.t_Wrapping u8) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping u8) (Core.Num.Wrapping.t_Wrapping u8) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping u8) (Core.Num.Wrapping.t_Wrapping u8) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping u16) (Core.Num.Wrapping.t_Wrapping u16) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping u16) (Core.Num.Wrapping.t_Wrapping u16) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping u16) (Core.Num.Wrapping.t_Wrapping u16) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping u16) (Core.Num.Wrapping.t_Wrapping u16) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping u32) (Core.Num.Wrapping.t_Wrapping u32) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping u32) (Core.Num.Wrapping.t_Wrapping u32) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping u32) (Core.Num.Wrapping.t_Wrapping u32) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping u32) (Core.Num.Wrapping.t_Wrapping u32) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping u64) (Core.Num.Wrapping.t_Wrapping u64) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping u64) (Core.Num.Wrapping.t_Wrapping u64) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping u64) (Core.Num.Wrapping.t_Wrapping u64) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping u64) (Core.Num.Wrapping.t_Wrapping u64) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping u128) (Core.Num.Wrapping.t_Wrapping u128) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping u128) (Core.Num.Wrapping.t_Wrapping u128) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping u128) (Core.Num.Wrapping.t_Wrapping u128) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping u128) (Core.Num.Wrapping.t_Wrapping u128) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping usize) (Core.Num.Wrapping.t_Wrapping usize) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping usize) (Core.Num.Wrapping.t_Wrapping usize) =
  { product = fun (iter: i) -> () }

let impl: t_Sum (Core.Num.Wrapping.t_Wrapping usize) (Core.Num.Wrapping.t_Wrapping usize) =
  { sum = fun (iter: i) -> () }

let impl: t_Product (Core.Num.Wrapping.t_Wrapping usize) (Core.Num.Wrapping.t_Wrapping usize) =
  { product = fun (iter: i) -> () }

(* item error backend *)

(* item error backend *)

(* item error backend *)

(* item error backend *)

(* item error backend *)

(* item error backend *)

(* item error backend *)

(* item error backend *)

let impl
      (#t #u #e: Type)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __0: Core.Marker.t_Sized t)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __1: Core.Marker.t_Sized u)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __2: Core.Marker.t_Sized e)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __3: t_Sum t u)
    : t_Sum (Core.Result.t_Result t e) (Core.Result.t_Result u e) =
  {
    sum
    =
    fun
      (#t: Type)
      (#u: Type)
      (#e: Type)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __0: Core.Marker.t_Sized t)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __1: Core.Marker.t_Sized u)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __2: Core.Marker.t_Sized e)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __3: t_Sum t u)
      (iter: i)
      ->
      ()
  }

let impl
      (#t #u #e: Type)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __0: Core.Marker.t_Sized t)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __1: Core.Marker.t_Sized u)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __2: Core.Marker.t_Sized e)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __3: t_Product t u)
    : t_Product (Core.Result.t_Result t e) (Core.Result.t_Result u e) =
  {
    product
    =
    fun
      (#t: Type)
      (#u: Type)
      (#e: Type)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __0: Core.Marker.t_Sized t)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __1: Core.Marker.t_Sized u)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __2: Core.Marker.t_Sized e)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __3: t_Product t u)
      (iter: i)
      ->
      ()
  }

let impl
      (#t #u: Type)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __0: Core.Marker.t_Sized t)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __1: Core.Marker.t_Sized u)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __2: t_Sum t u)
    : t_Sum (Core.Option.t_Option t) (Core.Option.t_Option u) =
  {
    sum
    =
    fun
      (#t: Type)
      (#u: Type)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __0: Core.Marker.t_Sized t)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __1: Core.Marker.t_Sized u)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __2: t_Sum t u)
      (iter: i)
      ->
      ()
  }

let impl
      (#t #u: Type)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __0: Core.Marker.t_Sized t)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __1: Core.Marker.t_Sized u)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __2: t_Product t u)
    : t_Product (Core.Option.t_Option t) (Core.Option.t_Option u) =
  {
    product
    =
    fun
      (#t: Type)
      (#u: Type)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __0: Core.Marker.t_Sized t)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __1: Core.Marker.t_Sized u)
      (#[FStar.Tactics.Typeclasses.tcresolve ()] __2: t_Product t u)
      (iter: i)
      ->
      ()
  }